# Алгоритм обработки запроса (GET /api/me):

## 1. Поступление запроса

Поступает GET запрос на `/api/me`.

**Требования**: 
- Запрос требует аутентификации через Access Token
- Access Token должен быть передан в заголовке `Authorization`
- Формат заголовка: `Authorization: Bearer {accessToken}`
- Запрос не требует тела (body)

## 2. Middleware обработка (до контроллера)

Запрос проходит через middleware аутентификации:

### 2.1. Auth Middleware (`authMiddlewares`)

Выполняется проверка аутентификации пользователя:

#### 2.1.1. Проверка заголовка Authorization
- Извлекается заголовок `Authorization` из запроса: `req.headers.authorization`
- **Проверка наличия заголовка**:
  - Если заголовок отсутствует:
    - Вызывается `ApiError.UnauthorizedError()`
    - Возвращается ответ со статусом **401** и кодом ошибки **3** (`unauthorized`)
    - Запрос не передается в контроллер

#### 2.1.2. Извлечение токена из заголовка
- Заголовок `Authorization` имеет формат: `"Bearer {token}"`
- Выполняется разбор заголовка: `authorizationHeader.split(" ")[1]`
- Извлекается токен (вторая часть после пробела)
- **Проверка наличия токена**:
  - Если токен отсутствует (заголовок не содержит токена после "Bearer"):
    - Вызывается `ApiError.UnauthorizedError()`
    - Возвращается ответ со статусом **401** и кодом ошибки **3** (`unauthorized`)
    - Запрос не передается в контроллер

#### 2.1.3. Валидация Access Token (`tokenService.validateAccessToken`)
- Выполняется валидация Access Token:
  - Используется `jwt.verify(token, JWT_ACCESS_SECRET)` для проверки токена
  - Проверяется подпись токена с использованием секретного ключа `JWT_ACCESS_SECRET`
  - Проверяется срок действия токена (expiresIn: '1h')
  - Если токен валиден, возвращается payload (PersonDTO) с данными:
    - `id`: ID пользователя
    - `email`: email пользователя
    - `superuser`: статус суперпользователя
    - `isActivated`: статус активации аккаунта
  - Если токен невалиден (истек, неверная подпись, отсутствует), возвращается `null`
- **Проверка валидности токена**:
  - Если `person` равен `null` (токен невалиден):
    - Вызывается `ApiError.UnauthorizedError()`
    - Возвращается ответ со статусом **401** и кодом ошибки **3** (`unauthorized`)
    - Запрос не передается в контроллер

#### 2.1.4. Проверка активации аккаунта
- Проверяется статус активации аккаунта: `person.isActivated`
- **Проверка активации**:
  - Если `person.isActivated` равен `false`:
    - Вызывается `ApiError.UnauthorizedError()`
    - Возвращается ответ со статусом **401** и кодом ошибки **3** (`unauthorized`)
    - Запрос не передается в контроллер
  - Только активированные пользователи могут получить доступ к своим данным

#### 2.1.5. Сохранение данных пользователя
- Если все проверки пройдены, данные пользователя сохраняются в `req.person`:
  - `req.person = person`
  - Это позволяет контроллеру использовать данные пользователя без повторного запроса к БД
- Вызывается `next()` для передачи запроса в контроллер

#### 2.1.6. Обработка исключений
- Если на любом этапе middleware возникает исключение (try-catch):
  - Вызывается `ApiError.UnauthorizedError()`
  - Возвращается ответ со статусом **401** и кодом ошибки **3** (`unauthorized`)
  - Запрос не передается в контроллер

## 3. Обработка в контроллере (`personController.getMe`)

### 3.1. Извлечение ID пользователя
- Извлекается `id` из `req.person` (данные были установлены middleware):
  - `const { id } = req.person`
  - ID был получен из payload Access Token при валидации

### 3.2. Получение пользователя из БД (`personService.getPerson`)
- Выполняется получение полных данных пользователя из БД:
  - Используется `db.findPersonById(id)`
  - Выполняется запрос в PostgreSQL для получения пользователя по ID
  - Возвращается объект пользователя со всеми полями из таблицы `auth.person`

### 3.3. Преобразование в DTO (`PersonDTO`)
- Полученный объект пользователя преобразуется в DTO (Data Transfer Object):
  - Создается экземпляр `new PersonDTO(person)`
  - PersonDTO фильтрует данные и возвращает только безопасные поля:
    - `id`: ID пользователя
    - `email`: email пользователя
    - `superuser`: статус суперпользователя
    - `isActivated`: статус активации аккаунта (преобразуется из `is_activated`)
- **Фильтрация чувствительных данных**:
  - Хешированный пароль (`password`) не включается в ответ
  - Активационная ссылка (`activation_link`) не включается в ответ
  - Другие внутренние поля БД не включаются в ответ

### 3.4. Формирование ответа
- Возвращается ответ со статусом **200 OK**
- Тело ответа содержит объект PersonDTO:
```json
{
  "id": "number",
  "email": "string",
  "superuser": "boolean",
  "isActivated": "boolean"
}
```

## 4. Обработка ошибок

Если на любом этапе возникает ошибка:
- Ошибка передается в `next(error)`
- Обрабатывается через `errorApiMiddlewares`
- Возвращается соответствующий HTTP статус и код ошибки

### Возможные ошибки:
- **401** (код 3): Unauthorized - возникает в следующих случаях:
  - Заголовок `Authorization` отсутствует
  - Токен отсутствует в заголовке (неправильный формат)
  - Access Token невалиден или истек
  - Аккаунт не активирован (`isActivated = false`)
  - Любая ошибка при валидации токена


## 5. Особенности реализации

### 5.1. Защищенный endpoint
- Endpoint требует аутентификации через Access Token
- Только авторизованные и активированные пользователи могут получить доступ
- Это защищает персональные данные пользователя

### 5.2. Двойная проверка активации
- Проверка активации выполняется дважды:
  1. В middleware при валидации токена (проверка `isActivated` из payload)
  2. В БД при получении пользователя (актуальный статус из БД)
- Это обеспечивает дополнительную безопасность

### 5.3. Фильтрация данных через DTO
- Endpoint использует PersonDTO для фильтрации данных перед отправкой
- Возвращаются только безопасные поля: `id`, `email`, `superuser`, `isActivated`
- Чувствительные данные (хешированный пароль, activation_link) не передаются клиенту
- Это обеспечивает безопасность и предотвращает утечку конфиденциальной информации

### 5.4. Использование данных из токена
- ID пользователя берется из Access Token (payload)
- Это позволяет избежать дополнительного запроса к БД для получения ID
- Однако для получения полных данных все равно выполняется запрос к БД

### 5.5. Срок действия токена
- Access Token имеет срок действия 1 час
- После истечения токена необходимо обновить его через `/api/refresh`
- Это обеспечивает безопасность: даже если токен скомпрометирован, он будет недействителен через час

## 6. Безопасность

### 6.1. Защита от неавторизованного доступа
- Endpoint недоступен без валидного Access Token
- Это предотвращает получение данных пользователя неавторизованными запросами

### 6.2. Проверка активации
- Только активированные пользователи могут получить доступ
- Неактивированные пользователи получат 401, даже с валидным токеном

### 6.3. Валидация токена
- Проверяется подпись токена с использованием секретного ключа
- Проверяется срок действия токена
- Это предотвращает использование поддельных или истекших токенов

### 6.4. Защита чувствительных данных
- Использование PersonDTO обеспечивает фильтрацию чувствительных данных
- Хешированный пароль и другие внутренние поля не передаются клиенту
- Это соответствует best practices для API безопасности

## Итоговая последовательность:

1. GET запрос → `/api/me`
2. Middleware: Проверка заголовка Authorization
3. Middleware: Извлечение токена из заголовка
4. Middleware: Валидация Access Token
5. Middleware: Проверка активации аккаунта
6. Middleware: Сохранение данных пользователя в req.person
7. Контроллер: Извлечение ID из req.person
8. Контроллер: Получение пользователя из БД по ID
9. Контроллер: Преобразование в PersonDTO (фильтрация данных)
10. Контроллер: Возврат данных пользователя через DTO (200 OK)

## Сценарии использования:

### Сценарий 1: Успешное получение данных
- Access Token присутствует и валиден
- Аккаунт активирован
- Пользователь найден в БД
- Данные преобразуются в PersonDTO (фильтрация чувствительных полей)
- Возвращаются безопасные данные пользователя (200 OK)

### Сценарий 2: Отсутствует заголовок Authorization
- Заголовок Authorization отсутствует
- Возвращается 401 (код 3) с сообщением "Unauthorized"

### Сценарий 3: Неверный формат заголовка
- Заголовок Authorization присутствует, но не содержит токена
- Возвращается 401 (код 3) с сообщением "Unauthorized"

### Сценарий 4: Access Token невалиден
- Access Token присутствует, но невалиден или истек
- Возвращается 401 (код 3) с сообщением "Unauthorized"

### Сценарий 5: Аккаунт не активирован
- Access Token валиден, но аккаунт не активирован (`isActivated = false`)
- Возвращается 401 (код 3) с сообщением "Unauthorized"

### Сценарий 6: Пользователь не найден в БД
- Access Token валиден, но пользователь с таким ID не найден в БД
- Возвращается ошибка (зависит от реализации `db.findPersonById`)

## 7. Использование на клиенте

### 7.1. Запрос с токеном
```javascript
fetch('/api/me', {
  method: 'GET',
  headers: {
    'Authorization': `Bearer ${accessToken}`
  }
})
```

### 7.2. Обработка ответа
- При успехе (200): получить данные пользователя
- При ошибке (401): обновить токен через `/api/refresh` или перенаправить на страницу входа

### 7.3. Обновление токена
- Если токен истек, необходимо использовать `/api/refresh` для получения нового Access Token
- После обновления повторить запрос к `/api/me`
