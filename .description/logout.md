# Алгоритм обработки запроса (GET /api/logout):

## 1. Поступление запроса

Поступает GET запрос на `/api/logout`.

**Примечание**: Запрос не требует тела (body), но должен содержать cookie `refreshToken` для корректного завершения сессии.

## 2. Middleware обработка (до контроллера)

Запрос проходит через middleware:

### 2.1. Device Info Middleware (`deviceInfoMiddleware`)
Извлекается информация об устройстве, с которого поступил запрос:
- **IP адрес**: извлекается из заголовка `x-forwarded-for` или `req.socket.remoteAddress`
- **Тип устройства**: определяется как `mobile`, `tablet` или `desktop` на основе `req.useragent`
- **Информация о браузере**: парсится из `User-Agent` через `device-detector-js`
  - `agent_name`: название браузера (например, "Chrome", "Firefox")
  - `agent_version`: версия браузера
- **Информация об ОС**: парсится из `User-Agent`
  - `os_name`: название операционной системы
  - `os_version`: версия операционной системы

Результат сохраняется в `req.device`:
```js
{
  device_type: "desktop" | "mobile" | "tablet",
  agent_name: "string",
  agent_version: "string",
  os_name: "string",
  os_version: "string",
  ip_address: "string"
}
```

**Примечание**: Информация об устройстве извлекается, но не используется для валидации при logout (в отличие от refresh endpoint).

## 3. Обработка в контроллере (`personController.logout`)

### 3.1. Извлечение Refresh Token из Cookie
- Извлекается `refreshToken` из cookies запроса: `req.cookies.refreshToken`
- Если cookie отсутствует, `refreshToken` будет `undefined`

### 3.2. Валидация Refresh Token (`tokenService.validateRefreshToken`)
- Выполняется валидация refresh токена:
  - Используется `jwt.verify(token, JWT_REFRESH_SECRET)` для проверки токена
  - Проверяется подпись токена и срок его действия
  - Если токен валиден, возвращается payload с данными:
    - `id`: ID пользователя
    - `email`: email пользователя
    - `superuser`: статус суперпользователя
    - `isActivated`: статус активации аккаунта
    - `jti`: уникальный идентификатор сессии (JWT ID)
  - Если токен невалиден (истек, неверная подпись, отсутствует), возвращается `null`

### 3.3. Удаление сессии из Redis (`sessionService.removeSession`)
- **Условное выполнение**: Удаление сессии происходит только если `payload` валиден (не `null`)
- Если `payload` существует:
  - Выполняется удаление сессии из Redis через `sessionService.removeSession(payload.id, payload.jti)`
  - Сессия удаляется по ключу, сформированному на основе `person_id` и `jti`
- Если `payload` равен `null` (токен отсутствует или невалиден):
  - Удаление сессии не выполняется (сессия может уже не существовать или быть невалидной)
  - Процесс продолжается без ошибки

**Примечание**: Даже если refreshToken отсутствует или невалиден, процесс logout продолжается и cookie все равно очищается. Это обеспечивает "мягкий" logout, который всегда успешен.

### 3.4. Очистка Refresh Token Cookie
- Выполняется очистка cookie `refreshToken`:
  - Используется `res.clearCookie('refreshToken')`
  - Cookie удаляется из браузера клиента
  - Это происходит независимо от валидности токена

### 3.5. Формирование ответа
- Возвращается ответ со статусом **204 No Content**
- Тело ответа отсутствует (пустое)

## 4. Обработка ошибок

Если на любом этапе возникает ошибка:
- Ошибка передается в `next(error)`
- Обрабатывается через `errorApiMiddlewares`
- Возвращается соответствующий HTTP статус и код ошибки

**Важно**: В текущей реализации logout не выбрасывает ошибки при отсутствии или невалидности refreshToken. Процесс всегда завершается успешно (204), даже если сессия не была найдена или удалена.

## 5. Особенности реализации

### 5.1. "Мягкий" logout
- Logout всегда возвращает 204, даже если:
  - RefreshToken отсутствует в cookies
  - RefreshToken невалиден или истек
  - Сессия не найдена в Redis
- Это обеспечивает безопасность: клиент всегда может "выйти", даже если сессия уже была удалена или истекла

### 5.2. Отсутствие валидации устройства
- В отличие от `/api/refresh`, logout не проверяет соответствие устройства сессии
- Это позволяет пользователю выйти с любого устройства, даже если оно не соответствует сохраненной сессии

### 5.3. Не требуется Access Token
- Logout не требует наличия Access Token в заголовке Authorization
- Достаточно наличия refreshToken в cookies (который может быть невалидным)

## Итоговая последовательность:

1. GET запрос → `/api/logout`
2. Middleware: Device Info (информация извлекается, но не валидируется)
3. Контроллер: Извлечение refreshToken из cookies
4. Валидация refreshToken (если токен валиден → получаем payload с id и jti)
5. Удаление сессии из Redis (только если payload валиден)
6. Очистка refreshToken cookie (всегда выполняется)
7. Возврат 204 No Content (всегда успешно)

## Сценарии использования:

### Сценарий 1: Успешный logout с валидным токеном
- RefreshToken присутствует и валиден
- Сессия найдена и удалена из Redis
- Cookie очищена
- Возвращается 204

### Сценарий 2: Logout без токена
- RefreshToken отсутствует в cookies
- Удаление сессии не выполняется
- Cookie очищается (если была установлена)
- Возвращается 204

### Сценарий 3: Logout с истекшим/невалидным токеном
- RefreshToken присутствует, но невалиден или истек
- Удаление сессии не выполняется
- Cookie очищается
- Возвращается 204
